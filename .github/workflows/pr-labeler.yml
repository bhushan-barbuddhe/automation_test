# .github/workflows/pr-labeler.yml
name: "PR Labeler"

on:
  pull_request:
    types: [opened, reopened]
    branches: [main, master, develop, development, uat] # Label PRs to these branches

permissions:
  contents: read
  pull-requests: write

jobs:
  label:
    runs-on: ubuntu-latest
    # Only run for PRs targeting main, master, develop, development, or uat branches
    if: contains(fromJson('["main", "master", "develop", "development", "uat"]'), github.event.pull_request.base.ref)
    steps:
      - name: Auto Label PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            const title = pr.title.toLowerCase();
            const targetBranch = pr.base.ref;
            const labels = [];

            console.log(`Labeling PR #${pr.number} targeting ${targetBranch} branch`);

            // Skip release note for maintenance tasks
            const skipPrefixes = ['chore', 'ci', 'style', 'test', 'refactor'];
            const hasSkipPrefix = skipPrefixes.some(prefix => 
              title.startsWith(prefix + ':') || title.startsWith(prefix + '(')
            );
            
            if (hasSkipPrefix) {
              labels.push('skip-release');
            }

            // Type detection from title
            if (title.includes('feat') || title.includes('feature')) {
              labels.push('feature');
            } else if (title.includes('fix') || title.includes('bug')) {
              labels.push('bug');
            } else if (title.includes('docs') || title.includes('doc')) {
              labels.push('docs');
            } else if (title.includes('refactor')) {
              labels.push('refactor');
            }

            // Size based on changes
            const totalChanges = (pr.additions || 0) + (pr.deletions || 0);
            if (totalChanges < 50) {
              labels.push('small');
            } else if (totalChanges < 200) {
              labels.push('medium');
            } else {
              labels.push('large');
            }

            // Get changed files for better categorization
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            const changedFiles = files.map(f => f.filename);
            
            // Backend changes
            if (changedFiles.some(f => f.endsWith('.py'))) {
              labels.push('backend');
            }
            
            // Frontend changes
            if (changedFiles.some(f => f.endsWith('.js') || f.endsWith('.vue') || f.endsWith('.html') || f.endsWith('.css'))) {
              labels.push('frontend');
            }
            
            // DocType changes
            if (changedFiles.some(f => f.includes('doctype') && f.endsWith('.json'))) {
              labels.push('doctype');
            }

            // Add branch-specific labels
            if (targetBranch === 'main' || targetBranch === 'master') {
              labels.push('release');
              console.log('üöÄ Production release PR');
            } else if (targetBranch === 'uat') {
              labels.push('uat-release');
              console.log('üß™ UAT release PR');
            } else if (targetBranch === 'develop' || targetBranch === 'development') {
              labels.push('develop');
              console.log('üõ†Ô∏è Development PR');
            }

            // Get existing labels to avoid permission errors
            const { data: existingLabels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            const existingLabelNames = existingLabels.map(label => label.name.toLowerCase());
            
            // Only add labels that already exist in the repo
            const validLabels = labels.filter(label => existingLabelNames.includes(label.toLowerCase()));
            
            // Add labels with error handling
            if (validLabels.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: validLabels
                });
                
                console.log(`‚úÖ Added labels: ${validLabels.join(', ')}`);
              } catch (error) {
                console.log(`‚ö†Ô∏è Error adding labels: ${error.message}`);
              }
            }
            
            // Log missing labels for manual creation
            const missingLabels = labels.filter(label => !existingLabelNames.includes(label.toLowerCase()));
            if (missingLabels.length > 0) {
              console.log(`üìù Missing labels (create manually): ${missingLabels.join(', ')}`);
              console.log('Go to Issues ‚Üí Labels ‚Üí New label to create them');
            }
