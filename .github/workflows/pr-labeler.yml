# .github/workflows/pr-labeler.yml
name: "PR Labeler"

on:
  pull_request:
    types: [opened, reopened]
    branches: [main, master, develop, development, uat] # Label PRs to these branches

permissions:
  contents: read
  pull-requests: write

jobs:
  label:
    runs-on: ubuntu-latest
    # Only run for PRs targeting main, master, develop, development, or uat branches
    if: contains(fromJson('["main", "master", "develop", "development", "uat"]'), github.event.pull_request.base.ref)
    steps:
      - name: Auto Label PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            const title = pr.title.toLowerCase();
            const targetBranch = pr.base.ref;
            const labels = [];

            console.log(`Labeling PR #${pr.number} targeting ${targetBranch} branch`);

            // Skip release note for maintenance tasks
            const skipPrefixes = ['chore', 'ci', 'style', 'test', 'refactor'];
            const hasSkipPrefix = skipPrefixes.some(prefix => 
              title.startsWith(prefix + ':') || title.startsWith(prefix + '(')
            );
            
            if (hasSkipPrefix) {
              labels.push('skip-release-notes');
            }

            // Type detection from title
            if (title.includes('feat') || title.includes('feature')) {
              labels.push('feature');
            } else if (title.includes('fix') || title.includes('bug')) {
              labels.push('bug');
            } else if (title.includes('docs') || title.includes('doc')) {
              labels.push('docs');
            } else if (title.includes('refactor')) {
              labels.push('refactor');
            }

            // Get changed files for better categorization
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            const changedFiles = files.map(f => f.filename);
            
            // Backend changes
            if (changedFiles.some(f => f.endsWith('.py'))) {
              labels.push('backend');
            }
            
            // Frontend changes
            if (changedFiles.some(f => f.endsWith('.js') || f.endsWith('.vue') || f.endsWith('.html') || f.endsWith('.css'))) {
              labels.push('frontend');
            }
            
            // DocType changes
            if (changedFiles.some(f => f.includes('doctype') && f.endsWith('.json'))) {
              labels.push('doctype');
            }

            // Add branch-specific labels
            if (targetBranch === 'main' || targetBranch === 'master') {
              labels.push('release');
              console.log('🚀 Production release PR');
            } else if (targetBranch === 'uat') {
              labels.push('uat-release');
              console.log('🧪 UAT release PR');
            } else if (targetBranch === 'develop' || targetBranch === 'development') {
              labels.push('develop');
              console.log('🛠️ Development PR');
            }

            // Add labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: labels
              });
              
              console.log(`Added labels: ${labels.join(', ')}`);
            }
